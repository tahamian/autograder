package server

import (
	"context"
	"fmt"
	"github.com/docker/docker/api/types"
	"github.com/docker/docker/client"
	"github.com/docker/docker/pkg/archive"
	"github.com/gorilla/mux"
	"github.com/jhoonb/archivex"
	"github.com/mitchellh/go-homedir"
	log "github.com/sirupsen/logrus"
	"github.com/ulule/limiter"
	"github.com/ulule/limiter/drivers/middleware/stdlib"
	"gopkg.in/yaml.v2"
	"io/ioutil"
	"net/http"
	"os"
	"sync"
	"time"
	//"github.com/mitchellh/go-homedir"
)

type ConfigServer struct {
	//type AutoGenerated struct {
	BaseDir        string `yaml:"base_dir"`
	DockerfilePath string `yaml:"dockerfile_path"`
	Host           string `yaml:"host"`
	Labs           []struct {
	Name     string `yaml:"name"`
	Testcase []struct {
	Expected []struct {
	Feedback string   `yaml:"feedback"`
	Points   float64  `yaml:"points"`
	Values   []string `yaml:"values"`
} `yaml:"expected"`
	Type string `yaml:"type"`
} `yaml:"testcase"`
} `yaml:"labs"`
	LogDir      string `yaml:"log_dir"`
	ReadTimeout int    `yaml:"read_timeout"`
	Redis       Redis `yaml:"redis"`
	ServerPort   int    `yaml:"server_port"`
	TemplatePath string `yaml:"template_path"`
	TestCasePath string `yaml:"test_case_path"`
	WriteTimeout int    `yaml:"write_timeout"`
//}

}


type logerror struct {
	goError     error
	errortype   string
	info        string
	oldFileName string
	newFileName string
}

var config = create_config()

func create_config() ConfigServer{
	c :=  ConfigServer{}

	c.TemplatePath = "./templates"
	c.LogDir = "./logs"
	c.BaseDir = "./"

	c.Redis.MaxRetry = 3
	c.Redis.RedisServer = "0.0.0.0:6738"
	c.Redis.RateLimiter = "50-H"
	return c
}


func (c *ConfigServer) getConf(path string) *ConfigServer {

	yamlFile, err := ioutil.ReadFile(path)
	if err != nil {
		log.Info("yamlFile.Get err   #%v ", err)
	}
	err = yaml.Unmarshal(yamlFile, c)
	if err != nil {
		log.Info("Unmarshal: ", err)
	}

	return c
}

func build_image(){
	ctx := context.Background()
	cli, err := client.NewClientWithOpts(client.FromEnv, client.WithAPIVersionNegotiation())
	if err != nil {
		panic(err)
	}

	os.MkdirAll("marker/conf",0755)
	tar := new(archivex.TarFile)
	tar.Create("marker/conf.tar")
	tar.AddAll("marker", false)
	tar.Close()

	filePath, _ := homedir.Expand("marker")
	dockerBuildContext, _ := archive.TarWithOptions(filePath, &archive.TarOptions{})

	//dockerBuildContext, err := os.Open("marker/conf.tar")


	//imageName := "autograder"

	buildOptions := types.ImageBuildOptions{
		Dockerfile: "Dockerfile",
		Tags: []string{"autograder"},
		//Context: dockerBuildContext,
	}

	buildResponse, err := cli.ImageBuild(ctx, dockerBuildContext, buildOptions)
	if err != nil {
		log.Fatal(err)
	}

	defer func (){
		//err = dockerBuildContext.Close()
		//if err != nil {
		//	log.Fatal(err)
		//}

		err = buildResponse.Body.Close()
		if err != nil {
			log.Fatal(err)
		}
	}()


	//resp, err := cli.ContainerCreate(ctx, &container.Config{
	//	Image: "autograder",
	//}, nil, nil, "")
	//if err != nil {
	//	panic(err)
	//}
	//
	//fmt.Println(resp.ID)
	//if err != nil {
	//	log.Fatal(err)
	//}



	//out, err := cli.ImagePull(ctx, imageName, types.ImagePullOptions{})
	//if err != nil {
	//	panic(err)
	//}
	//
	//io.Copy(os.Stdout, out)
	//
	//resp, err := cli.ContainerCreate(ctx, &container.Config{
	//	Image: imageName,
	//}, nil, nil, "")
	//if err != nil {
	//	panic(err)
	//}
	//
	//if err := cli.ContainerStart(ctx, resp.ID, types.ContainerStartOptions{}); err != nil {
	//	panic(err)
	//}
	//
	//fmt.Println(resp.ID)
}

// Intializes the server builds marker docker image and
func StartServer(config_path string) *HTMLServer {

	config.getConf(config_path)

	build_image()

	store, rate := initalize_redis(config.Redis)
	middleware := stdlib.NewMiddleware(limiter.New(store, rate))

	_, cancel := context.WithCancel(context.Background())
	defer cancel()
	router := mux.NewRouter()


	router.Handle("/", middleware.Handler(http.HandlerFunc(handlemain)))
	router.HandleFunc("/upload", upload)


	htmlServer := HTMLServer{
		server: &http.Server{
			Addr:           config.Host + ":" + string(config.ServerPort),
			Handler:        router,
			ReadTimeout:    time.Duration(config.ReadTimeout),
			WriteTimeout:   time.Duration(config.WriteTimeout),
			MaxHeaderBytes: 1 << 20,
		},
	}

	htmlServer.wg.Add(1)

	go func() {
		fmt.Printf("\nHTMLServer : Service started : Host=%v\n", config.Host)
		err := htmlServer.server.ListenAndServe()
		if err != nil {

		}
		htmlServer.wg.Done()
	}()

	return &htmlServer



}


func (htmlServer *HTMLServer) Stop() error {
	const timeout = 5 * time.Second
	ctx, cancel := context.WithTimeout(context.Background(), timeout)
	defer cancel()
	fmt.Printf("\nHTMLServer : Service stopping\n")
	if err := htmlServer.server.Shutdown(ctx); err != nil {
		if err := htmlServer.server.Close(); err != nil {
			fmt.Printf("\nHTMLServer : Service stopping : Error=%v\n", err)
			return err
		}
	}
	htmlServer.wg.Wait()
	fmt.Printf("\nHTMLServer : Stopped\n")
	return nil
}

type HTMLServer struct {
	server *http.Server
	wg     sync.WaitGroup
}